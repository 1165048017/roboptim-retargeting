// Copyright (C) 2014 by Thomas Moulard, AIST, CNRS.
//
// This file is part of the roboptim.
//
// roboptim is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// roboptim is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with roboptim.  If not, see <http://www.gnu.org/licenses/>.

#include <fstream>
#include <boost/format.hpp>

#include <yaml-cpp/yaml.h>

#include <roboptim/retargeting/io/choreonoid-body-motion.hh>

namespace roboptim
{
  namespace retargeting
  {
    void
    writeBodyMotion (const std::string& filename,
		     boost::shared_ptr<roboptim::Trajectory<3> > result)
    {
      typedef Eigen::Quaternion<
	roboptim::Function::value_type> quaternion_t;

      std::ofstream fout (filename.c_str ());
      if (!fout.good ())
	throw std::runtime_error ("bad stream");

      int numFrames =
	static_cast<int> (result->parameters ().size () / result->outputSize ());
      double dt = result->length () / numFrames;

      int nDofs = static_cast<int> (result->outputSize ());

      YAML::Emitter out;
      out
	<< YAML::Comment("Generated by roboptim-retargeting")
	<< YAML::BeginMap
	<< YAML::Key << "type"
	<< YAML::Value << "BodyMotion"
	<< YAML::Key << "components"
	<< YAML::Value
	<< YAML::BeginSeq

	<< YAML::BeginMap
	<< YAML::Key << "type"
	<< YAML::Value << "MultiValueSeq"
	<< YAML::Key << "content"
	<< YAML::Value << "JointPosition"
	<< YAML::Key << "frameRate"
	<< YAML::Value << 1. / dt
	<< YAML::Key << "numFrames"
	<< YAML::Value << numFrames
	<< YAML::Key << "numParts"
	<< YAML::Value << nDofs - 6
	<< YAML::Key << "frames"
	<< YAML::Value

	<< YAML::BeginSeq;

      for (int frameId = 0; frameId < numFrames; ++frameId)
	{
	  roboptim::Function::vector_t
	    oneFrame = (*result) (frameId * dt);
	  out << YAML::Flow << YAML::BeginSeq;
	  for (int dofId = 6; dofId < result->outputSize (); ++dofId)
	    out << oneFrame[dofId];
	  out << YAML::EndSeq;
	}
      out << YAML::EndSeq;
      out << YAML::EndMap;

      out
	<< YAML::BeginMap
	<< YAML::Key << "type"
	<< YAML::Value << "MultiSE3Seq"
	<< YAML::Key << "content"
	<< YAML::Value << "LinkPosition"
	<< YAML::Key << "frameRate"
	<< YAML::Value << 1. / dt
	<< YAML::Key << "numFrames"
	<< YAML::Value << numFrames
	<< YAML::Key << "numParts"
	<< YAML::Value << 1
	<< YAML::Key << "format"
	<< YAML::Value << "XYZQWQXQYQZ"
	<< YAML::Key << "frames"
	<< YAML::Value

	<< YAML::BeginSeq;
      for (int frameId = 0; frameId < numFrames; ++frameId)
	{
	  roboptim::Function::vector_t
	    oneFrame = (*result) (frameId * dt);

	  // The free floating position (7 parameters) is considered as
	  // one part.
	  out << YAML::Flow << YAML::BeginSeq << YAML::BeginSeq;
	  for (int dofId = 0; dofId < 3; ++dofId)
	    out << oneFrame[dofId];

	  roboptim::Function::value_type
	    norm = oneFrame.segment (3, 3).norm ();

	  quaternion_t quaternion;
	  quaternion.setIdentity ();

	  if (norm >= 1e-10)
	    quaternion = Eigen::AngleAxisd
	      (norm, oneFrame.segment (3, 3).normalized ());

	  out
	    << quaternion.w ()
	    << quaternion.x () << quaternion.y () << quaternion.z ();

	  out << YAML::EndSeq << YAML::EndSeq;
	}
      out << YAML::EndSeq;

      out << YAML::EndMap;

      fout << out.c_str ();
    }

  } // end of namespace retargeting.
} // end of namespace roboptim.
